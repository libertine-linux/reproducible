#!/usr/bin/env sh
# This file is part of reproducible. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/reproducible/master/COPYRIGHT. No part of reproducible, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2019 The developers of reproducible. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/reproducible/master/COPYRIGHT.


set -e
set -f
set -u

program_name="reproducible-qemu"

_program_path_find()
{
	if [ "${0%/*}" = "$0" ]; then

		# We've been invoked by the interpreter as, say, bash program
		if [ -r "$0" ]; then
			pwd -P
		# Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
		else
			printf '\n'
		fi

	else

		# We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

		_program_path_find_parentPath()
		{
			parentPath="${scriptPath%/*}"
			if [ -z "$parentPath" ]; then
				parentPath='/'
			fi
			cd "$parentPath" 1>/dev/null
		}

		# pdksh / mksh have problems with unsetting a variable that was never set...
		if [ "${CDPATH+set}" = 'set' ]; then
			unset CDPATH
		fi

		if command -v realpath 1>/dev/null 2>/dev/null; then
			(
				scriptPath="$(realpath "$0")"

				_program_path_find_parentPath
				pwd -P
			)
		elif command -v readlink 1>/dev/null 2>/dev/null; then
			(
				local recursionDepth=0
				_program_path_resolve_symlinks_recursively()
				{
					local unresolvedPath="$1"
					
					recursionDepth=$((recursionDepth + 1))
					
					if [ $recursionDepth -gt 10 ]; then
						printf '%s\n' 'Recursion to depths greater than 10 is not allowed when resolving links.'
						return 1
					fi
					
					local potentialLinkDestination="$(readlink -- "$unresolvedPath")"
					
					if [ -z "$potentialLinkDestination" ]; then
						scriptPath="$unresolvedPath"
						return 0
					fi
					local linkDestination="$potentialLinkDestination"
					local parentFolderPath="${unresolvedPath%/*}"
					
					if [ "$parentFolderPath" = "$unresolvedPath" ]; then
						_program_path_resolve_symlinks_recursively "$linkDestination"
					else
						case "$linkDestination" in
														
							/*)
								_program_path_resolve_symlinks_recursively "$linkDestination"
							;;
							
							*)
								_program_path_resolve_symlinks_recursively "$parentFolderPath"/"$linkDestination"
							;;
							
						esac
					fi
				}

				scriptPath="$0"
				_program_path_resolve_symlinks_recursively "$scriptPath"

				_program_path_find_parentPath
				pwd -P
			)
		else
			# This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
			(
				scriptPath="$0"

				_program_path_find_parentPath
				pwd -P
			)
		fi

	fi
}

fail()
{
	local exitCode="$1"
	local message="$2"
	
	printf '%s:FAIL:%s\n' "$program_name" "$message" 1>&2
	exit $exitCode
}

depends()
{
	local binary
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s:%s\n' "$program_name" "The binary `$binary` is not on the PATH" 1>&2
			local EX_OSFILE=72
			exit $EX_OSFILE
		fi
	done
}

# For documentation only.
depends_provided_by_macports()
{
	:
}

depends cat chmod cpio gzip
reproducible_qemu_makeInitFile()
{
	local initFilePath="$reproducible_chrootFolderPath"/init
	
	cat >"$initFilePath" <<-EOF
		#!/bin/sh

		set -e
		set -f
		set -u

		export PATH='/usr/sbin:/sbin:/usr/bin:/bin'
		export LOGNAME='currentuser'
		export USER='currentuser'
		export HOME='/home/currentuser'
		export LANG=C.UTF-8
		export LANGUAGE=en_US:en
		
		busybox mount -t proc -o noexec,nosuid,nodev proc /proc
		busybox mount -t sysfs -o noexec,nosuid,nodev sysfs /sys
		busybox mount -t devtmpfs -o exec,nosuid,mode=0755,size=2M devtmpfs /dev
		busybox mount -t devpts -o noexec,nosuid,mode=0620,gid=5 devpts /dev/pts
		busybox mount -t tmpfs -o noexec,nosuid,nodev shm /dev/shm
		
		# TODO: Load kernel modules; extract modloop.
		busybox modprobe 
		
		
		# TODO: Use an overlay mount to mount the disk OVER the initramfs; this is the simplest way.
		
		# overlayfs # squashfs
		
		
		# TODO: Need to use either pivot_root or switch_root
		busybox mkdir -m 0700 -p /disk${reproducible_qemu_disk0Index}-root
		busybox mount -t ext2 UUID=${reproducible_qemu_disk0Uuid} /disk${reproducible_qemu_disk0Index}-root
		cd /disk${reproducible_qemu_disk0Index}-root
		
		busybox mkdir initrd
		busybox pivot_root . initrd
		
		# TODO: bin sbin etc are now under /initrd/bin etc
		
		# WON'T WORK!!!
		exec busybox chroot . busybox su \
			-p \
			-s /bin/sh \
			-c 'exec /su-command' \
			currentuser \
			 <dev/console >dev/console 2>&1
	EOF
	
	chmod 0700 "$initFilePath"
}

reproducible_qemu_linuxKernelVersion()
{
	:
}

depends rm mkdir ls head
depends grep sort cp
reproducible_qemu_parseKernelModuleDependencies()
{	
	if reproducible_cachedVersion "$reproducible_qemu_kernelModulesFolderPath"; then
		return 0
	fi
	
	rm -rf "$reproducible_qemu_kernelModulesFolderPath"
	mkdir -m 0700 -p "$reproducible_qemu_kernelModulesFolderPath"
	
		local modulesFolderPath="$reproducible_extractedInitramfsFolderPath"/lib/modules
		cd "$reproducible_extractedInitramfsFolderPath"/lib/modules 1>/dev/null 2>/dev/null
			local linuxKernelVersion="$(ls -1 | head -n 1)"
		cd - 1>/dev/null 2>/dev/null
		
		
		xxxxx
		
		
		
		
		
	
	cp -f "$reproducible_versionFilePath" "$reproducible_qemu_kernelModulesFolderPath"
	
	# TODO: Also add etc/modprobe.d/
	
	# TODO: Also add lib/modules/"$version" subset? Or just rsync the lot?
	
	#mkdir -m 0700 -p "$chrootExtraFolderPath"/lib/modules
	
	
	local moduleDependenciesFilePath="$modulesFolderPath"/"$version"/modules.dep
	
	{
		local moduleWeWant
		for moduleWeWant in kernel/fs/squashfs/squashfs.ko
		do
			grep -m 1 '^'"$modulesWeWant"': ' "$moduleDependenciesFilePath"
		done
	} | sort >"$reproducible_temporaryFolderPath"/modules.dep
	
	local moduleRelativePath
	local junk
	while IFS=':' read -r moduleRelativePath junk
	do
		local parentFolderPath="$(dirname "$moduleRelativePath")"
		mkdir -m 0700 -p "$X"/"$parentFolderPath"
		cp "$moduleRelativePath" "$X"/"$moduleRelativePath"
	done <"$reproducible_temporaryFolderPath"/modules.dep
}

depends rm find cpio gzip
reproducible_qemu_createInitialRamdiskCpioArchive()
{
	rm -rf "$reproducible_qemu_initialRamdiskCpioArchiveFilePath"
	
	cd "$reproducible_chrootFolderPath" 1>/dev/null 2>/dev/null
		find . | cpio -o -H 'newc' -R 0:0 2>/dev/null | gzip -c >"$reproducible_qemu_initialRamdiskCpioArchiveFilePath"
	cd - 1>/dev/null 2>/dev/null
}

depends mkdir
reproducible_qemu_createQemuFolderIfNeeded()
{
	mkdir -m 0700 -p "$reproducible_qemu_qemuFolderPath"
}

depends_provided_by_macports qemu-img mke2fs
reproducible_qemu_createDisk0IfNeeded()
{
	if [ ! -f "$reproducible_qemu_disk0FilePath" ]; then
		qemu-img create -f raw "$reproducible_qemu_disk0FilePath" "$reproducible_qemu_disk0Size" 1>/dev/null 2>/dev/null
		mke2fs -b 1024 -j -L "$reproducible_qemu_disk0Name" -o Linux -q -t ext2 -U "$reproducible_qemu_disk0Uuid" -F "$reproducible_qemu_disk0FilePath"
	fi
}

depends mkdir
reproducible_qemu_createDisk0MountPathIfNeeded()
{
	mkdir -m 0700 -p "$reproducible_qemu_disk0MountFolderPath"
}

depends umount
reproducible_qemu_mountDisk0AndUse()
{
	local callback="$1"
	shift 1
	
	_reproducible_qemu_unmountDisk0()
	{
		set +e
			umount -f "$reproducible_qemu_disk0MountFolderPath"
		set -e
	}
	trap _reproducible_qemu_unmountDisk0 EXIT SIGTERM
		
		fuse-ext2 "$reproducible_qemu_disk0FilePath" "$reproducible_qemu_disk0MountFolderPath" -o rw+,force,allow_root,noappledouble,noapplexattr,volname="Reproducible QEMU Disk ${reproducible_qemu_disk0Index}"
	
			"$callback" "$@"
		
		_reproducible_qemu_unmountDisk0
		
	trap - EXIT SIGTERM
}

depends sudo
depends_provided_by_macports rsync
reproducible_qemu_createOrUpdateDisk0WithMounts()
{
	reproducible_qemu_createQemuFolderIfNeeded
	
	reproducible_qemu_createDisk0IfNeeded
	
	reproducible_qemu_createDisk0MountPathIfNeeded
	
	reproducible_qemu_mountDisk0AndUse

	_reproducible_qemu_reproducible_qemu_createOrUpdateDisk0WithMounts_synchronizeMounts()
	{
		local mountFromFolderPath
		local mountToFolderPath
		local _recursiveMount
		while IFS=':' read -r mountFromFolderPath mountToFolderPath _recursiveMount
		do
			if [ -z "$mountFromFolderPath" ]; then
				continue
			fi
	
			sudo -p "Password for user '%u' to rsync as 0:0: " rsync \
				--quiet --recursive --links --perms --times --executability --sparse \
				--delete --delete-excluded --delete-after \
				--numeric-ids --chown=0:0 --chmod=D0700,Fg-rwx,Fo-rwx \
				"$mountFromFolderPath"/ "${reproducible_qemu_disk0MountFolderPath}${mountToFolderPath}"/
		done <<-EOF
			${reproducible_mount}
		EOF
	}
	reproducible_qemu_mountDisk0AndUse _reproducible_qemu_reproducible_qemu_createOrUpdateDisk0WithMounts_synchronizeMounts
}

depends_provided_by_macports qemu-system-x86_64
reproducible_qemu_execute()
{
	# Attempts to exit QEMU on Linux kernel panic; see second comment at https://unix.stackexchange.com/questions/443017/can-i-make-qemu-exit-with-failure-on-kernel-panic for a better option if the kernel supports pvpanic.
	set -- \
		-runas "$SUDO_UID":"$SUDO_GID" \
		-no-reboot \
		-nographic \
		-kernel "$reproducible_mirrorFolderPath"/vmlinuz \
		-drive index="$reproducible_qemu_disk0Index",media=disk,snapshot=off,format=raw,file="$reproducible_qemu_disk0FilePath" \
		-initrd "$reproducible_qemu_initialRamdiskCpioArchiveFilePath" \
		-append "root=/dev/$reproducible_qemu_disk0Name console=ttyS0 quiet kernel.panic=-1" \
			-m "$reproducible_qemu_memorySize" \
			-k en-us
	exec qemu-system-x86_64 "$@"
}

reproducible_qemu_commandLineArguments()
{
	local environment_parseCommandLineArguments_message="${program_name}:  Enters an Alpine Linux QEMU virtual instance.

Usage: ${program_name} -h | --help
Usage: ${program_name} [-c|--configuration /path/to/configuration/folder] [-o|--output /path/to/output/folder [-m|--mount from1:to1:recursive1,from2:to2:recursive2]]

If the configuration folder path is not provided, it defaults to program_location/sample-configuration.

If the output folder path is not provided, it defaults to program_location/output. The output folder path is created as necessary.

The mount argument is a triplet of from folder path and to folder path and true/false for recursive mounting. It can be repeated.
from folder path and to folder path should not contain colons or new lines.
"
	local reproducible_mount=""
	_additionalArgumentsCallback()
	{
		case "$key" in
			-m|--mount)
				environment_parseCommandLineArguments_missingArgument "$@"
				reproducible_mount="${reproducible_mount}
${value}"
				_additionalArgumentsCallback_shiftUp=1
			;;

			--mount=*)
				value="${key##--mount=}"
				reproducible_mount="${reproducible_mount}
${value}"
			;;

			-m*)
				environment_parseCommandLineArguments_alreadyParsed $reproducible_configurationFolderPathParsed
				value="${key##-m}"
				reproducible_mount="${reproducible_mount}
${value}"
			;;

			*)
				environment_parseCommandLineArguments_errorHelp "Unexpected argument '$key'"
			;;
		esac
	}
	
	_positionalArgumentsCallback()
	{
		if [ $# -eq 0 ]; then
			environment_parseCommandLineArguments_errorHelp "At least one positional argument should be specified (an absolute path to a binary to run in the chroot)"
		fi
	}

	reproducible_configurationFolderPath="$(pwd)"/sample-configuration
	reproducible_outputFolderPath="$(pwd)"/output
	reproducible_parseCommandLineArguments _additionalArgumentsCallback _positionalArgumentsCallback "$@"
}

reproducible_qemu_main()
{
	cd "$(_program_path_find)"/.. 1>/dev/null 2>/dev/null

	. "$(pwd)"/functions/reproducible.functions

	local reproducible_positionalArgumentsStartAt
	local reproducible_configurationFolderPath
	local reproducible_outputFolderPath
	reproducible_qemu_commandLineArguments "$@"
	
	reproducible_validateCommandLineArguments

	local reproducible_temporaryFolderPath
	local reproducible_versionFilePath
	local reproducible_packagesFilePath
	local reproducible_busyboxStaticBinariesFilePath
	local reproducible_mirrorFolderPath
	local reproducible_mirrorVersionFilePath
	local reproducible_indexFolderPath
	local reproducible_indexVersionFilePath
	local reproducible_packagesFolderPath
	local reproducible_packagesVersionFilePath
	local reproducible_extractedPackagesFolderPath
	local reproducible_extractedPackagesVersionFilePath
	local reproducible_extractedPackagesPackagesFilePath
	local reproducible_extractedPackagesBusyboxStaticBinariesFilePath
	local reproducible_extractedInitramfsFolderPath
	local reproducible_extractedInitramfsVersionFilePath
	local reproducible_majorVersion
	local reproducible_minorVersion
	local reproducible_revisionVersion
	local reproducible_apkToolsVersion
	local reproducible_versionMirror
	local reproducible_releasesMirror
	local reproducible_architecture
	local reproducible_chrootFolderPath
	reproducible_setEnvironmentVariables
	
	reproducible_macports
	
	local reproducible_qemu_memorySize='1G'
	local reproducible_qemu_initialRamdiskCpioArchiveFilePath="$reproducible_temporaryFolderPath"/initramfs.cpio.gz

	local reproducible_qemu_disk0Uuid='d2c4a813-877e-44d1-8b3b-0b32139d7ee6'
	local reproducible_qemu_disk0Index='0'
	local reproducible_qemu_disk0Name='hda'
	local reproducible_qemu_disk0Size='1G'
	local reproducible_qemu_disk0MountFolderPath
	local reproducible_qemu_disk0FilePath
	
	local reproducible_qemu_kernelModulesFolderPath="$reproducible_outputFolderPath"/kernel-modules
	local reproducible_qemu_qemuFolderPath="$reproducible_outputFolderPath"/qemu
	local reproducible_qemu_disk0FilePath="$reproducible_qemu_qemuFolderPath"/disk${reproducible_qemu_disk0Index}.ext2.raw.img
	local reproducible_qemu_disk0MountFolderPath="$reproducible_qemu_qemuFolderPath"/disk0
	_callback()
	{
		reproducible_qemu_createOrUpdateDisk0WithMounts
		reproducible_qemu_makeInitFile
		reproducible_qemu_createInitialRamdiskCpioArchive
	}
	reproducible_runNotAsRoot _callback "$@"
	
	reproducible_qemu_execute
}

reproducible_qemu_main "$@"
