#!/usr/bin/env sh
# This file is part of reproducible. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/reproducible/master/COPYRIGHT. No part of reproducible, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2019 The developers of reproducible. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/reproducible/master/COPYRIGHT.


set -e
set -f
set -u

program_name="reproducible-qemu"

_program_path_find()
{
	if [ "${0%/*}" = "$0" ]; then

		# We've been invoked by the interpreter as, say, bash program
		if [ -r "$0" ]; then
			pwd -P
		# Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
		else
			printf '\n'
		fi

	else

		# We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

		_program_path_find_parentPath()
		{
			parentPath="${scriptPath%/*}"
			if [ -z "$parentPath" ]; then
				parentPath='/'
			fi
			cd "$parentPath" 1>/dev/null
		}

		# pdksh / mksh have problems with unsetting a variable that was never set...
		if [ "${CDPATH+set}" = 'set' ]; then
			unset CDPATH
		fi

		if command -v realpath 1>/dev/null 2>/dev/null; then
			(
				scriptPath="$(realpath "$0")"

				_program_path_find_parentPath
				pwd -P
			)
		elif command -v readlink 1>/dev/null 2>/dev/null; then
			(
				local recursionDepth=0
				_program_path_resolve_symlinks_recursively()
				{
					local unresolvedPath="$1"
					
					recursionDepth=$((recursionDepth + 1))
					
					if [ $recursionDepth -gt 10 ]; then
						printf '%s\n' 'Recursion to depths greater than 10 is not allowed when resolving links.'
						return 1
					fi
					
					local potentialLinkDestination="$(readlink -- "$unresolvedPath")"
					
					if [ -z "$potentialLinkDestination" ]; then
						scriptPath="$unresolvedPath"
						return 0
					fi
					local linkDestination="$potentialLinkDestination"
					local parentFolderPath="${unresolvedPath%/*}"
					
					if [ "$parentFolderPath" = "$unresolvedPath" ]; then
						_program_path_resolve_symlinks_recursively "$linkDestination"
					else
						case "$linkDestination" in
														
							/*)
								_program_path_resolve_symlinks_recursively "$linkDestination"
							;;
							
							*)
								_program_path_resolve_symlinks_recursively "$parentFolderPath"/"$linkDestination"
							;;
							
						esac
					fi
				}

				scriptPath="$0"
				_program_path_resolve_symlinks_recursively "$scriptPath"

				_program_path_find_parentPath
				pwd -P
			)
		else
			# This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
			(
				scriptPath="$0"

				_program_path_find_parentPath
				pwd -P
			)
		fi

	fi
}

fail()
{
	local exitCode="$1"
	local message="$2"
	
	printf '%s:FAIL:%s\n' "$program_name" "$message" 1>&2
	exit $exitCode
}

depends()
{
	local binary
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s:%s\n' "$program_name" "The binary `$binary` is not on the PATH" 1>&2
			local EX_OSFILE=72
			exit $EX_OSFILE
		fi
	done
}

depends mkdir
reproducible_qemu_generateExt2FileSystem()
{
	local reproducible_qemu
	reproducible_qemu_qemuFolderPath="$reproducible_outputFolderPath"/qemu
	mkdir -m 0700 -p "$reproducible_qemu"
	
	reproducible_qemu_disk0FilePath="$reproducible_qemu_qemuFolderPath"/disk${reproducible_qemu_disk0Index}.ext2.raw.img
	if [ ! -f "$reproducible_qemu_disk0FilePath" ]; then
		qemu-img create -f raw "$reproducible_qemu_disk0FilePath" "$reproducible_qemu_disk0Size" 1>/dev/null 2>/dev/null
		mke2fs -b 1024 -j -L "$reproducible_qemu_disk0Name" -o Linux -q -t ext2 -U "$reproducible_qemu_disk0Uuid" -F "$reproducible_qemu_disk0FilePath"
	fi
	
	reproducible_qemu_disk0MountFolderPath="$reproducible_qemu_qemuFolderPath"/disk0
	if [ ! -d "$reproducible_qemu_disk0MountFolderPath" ]; then
		mkdir -m 0700 -p "$reproducible_qemu_disk0MountFolderPath"
	fi
	# https://github.com/osxfuse/osxfuse/wiki/Ext
	# TODO: Check if already mounted.
	fuse-ext2 "$reproducible_qemu_disk0FilePath" "$reproducible_qemu_disk0MountFolderPath" -o force,noappledouble,noapplexattr,volname="Reproducible QEMU Disk ${reproducible_qemu_disk0Index}"
	
	reproducible_qemu_unmountDisk0()
	{
		fusermount -u "$reproducible_qemu_disk0MountFolderPath"
	}
	trap _reproducible_qemu_unmountDisk0 EXIT SIGTERM
	# unmount
	# 
	
	# osxfuse options:  noappledouble noapplexattr nobrowse volname="Reproducible QEMU Disk ${reproducible_qemu_disk0Index}"
	# mount
	#     sudo sed -e 's/OPTIONS="auto_xattr,defer_permissions"/OPTIONS="auto_xattr,defer_permissions,rw+"/' -i.orig /System/Library/Filesystems/fuse-ext2.fs/fuse-ext2.util
	
	local mountFromFolderPath
	local mountToFolderPath
	local recursiveMount
	local count=0
	while IFS=':' read -r mountFromFolderPath mountToFolderPath recursiveMount
	do
		if [ -z "$mountFromFolderPath" ]; then
			continue
		fi
		
		# --chown, but requires rsync 3.1.0 and root permission.
		
		local toFolder="$mountToFolderPath"
		
		rsync --quiet --recursive --links --perms --times --executability --sparse --delete --delete-excluded --delete-after --numeric-ids --chmod=D0700,Fg-rwx,Fo-rwx "$mountFromFolderPath"/ 
		
		set -- "$@" \
			-fsdev local,id="id${count}",path="$mountFromFolderPath",security_model=none \
			-device virtio-9p-pci,fsdev="id${count}",mount_tag="tag${count}"
		
		count=$((count + 1))
	done <<-EOF
		${reproducible_mount}
	EOF
	
	
	Create ext2 image files
		for each mount; estimate mount size using du for the mount path
	
	
	
	


		# We can create a non-partitioned file system very easily afer qemu-img:-
		# /usr/local/opt/e2fsprogs/sbin/mke2fs -b 1024 -j -L "${reproducible_qemu_disk0Name}" -o Linux -q -t ext4 -U d2c4a813-877e-44d1-8b3b-0b32139d7ee6 -F "$reproducible_qemu_disk0MountFolderPath"
		# Sadly, Alpine Linux DOES NOT build in the ext4 module, so it needs to be present on the initramfs along with modprobe. Perhaps include modloop?
		# We can bundle read-only mounts (/mount, /configuration) as part of the cpio; we'd need to optimize this with some caching, otherwise the rebuilds are horrible.
	
		# OPTION 2: Use Apple HPFS+ and DMGs
		# hdiutil create -quiet -size 512m -layout MBRSPUD -fs 'Case-sensitive HFS+' -type UDIF -nospotlight -noanyowners -uid 0 -gid 0 -mode 755 -volname "${reproducible_qemu_disk0Name}" "${reproducible_qemu_disk0Name}".dmg
		# can also specify -attach
	
		# OPTION 1: Copy read-only mounts into CPIO, Make an ext4 disk image ONCE, Use ext4fuse to read it readonly.
		# We will need to unpack modloop and modprobe the ext4 module
		#  Modloop
		#   https://superuser.com/questions/1290314/what-is-modloop-option-in-alpine
		#
		#   Read-only ext4 partition mounting
		#    ext4fuse hda.raw.img ./ext4 -o allow_other
		#    umount ./ext4
		#
		#.  -o[ffset] <bytes>	skip <bytes> at start of <dest>.  - we could install modloop to root of disk partition; another option is to put tarballs on a raw disk partition, then use dd to extract them alonf with a basic index table at the root of the partition!
		# unsquashfs -d ./root -q - -no-xattrs
	
		# Another option: Use an overlay filesystem with the squashfs file system
	
		# Mount your squashfs.file to /fm or somewhere else first.
		# Prepare a writable filesystem with 2 directories in it, say /to and /temp. prepare another writable directory /fin for the merged results. Mount them together as an overlayfs to your system ---
		#
		# mount -t overlay -o lowerdir=/fm,upperdir=/to,workdir=/temp overlay /fin
		# Now you can add/modify files in /fin. Once everything done, you can mksquashfs /fin to a new squashfs file,
		#
		# mksquashfs /fin newfile; umount /fin
	
	
		# Use file command to detect if disk has been formatted.
		# Extracting modloop requires unsquashfs, which isn't that common. We can pass the whole of Alpine Linux's modloop inside the initramfs.
	
		# NFS (not SAMBA as it lacks Unix file attributes)
	
	
		
}

depends cat chmod cpio gzip
reproducible_qemu_makeInitFile()
{
	local initFilePath="$reproducible_chrootFolderPath"/init
	{
		cat <<-'EOF'
			#!/bin/sh

			set -e
			set -f
			set -u

			export PATH='/usr/sbin:/sbin:/usr/bin:/bin'
			export LOGNAME='currentuser'
			export USER='currentuser'
			export HOME='/home/currentuser'
			export LANG=C.UTF-8
			export LANGUAGE=en_US:en
			
			busybox mount -t proc -o noexec,nosuid,nodev proc /proc
			busybox mount -t sysfs -o noexec,nosuid,nodev sysfs /sys
			busybox mount -t devtmpfs -o exec,nosuid,mode=0755,size=2M devtmpfs /dev
			busybox mount -t devpts -o noexec,nosuid,mode=0620,gid=5 devpts /dev/pts
			busybox mount -t tmpfs -o noexec,nosuid,nodev shm /dev/shm
		EOF
		
		local mountFromFolderPath
		local mountToFolderPath
		local recursiveMount
		local count=0
		while IFS=':' read -r mountFromFolderPath mountToFolderPath recursiveMount
		do
			if [ -z "$mountFromFolderPath" ]; then
				continue
			fi
			printf 'busybox mkdir -m 0755 -p %s\n' "$mountToFolderPath"
			printf 'busybox mount -t 9p -o trans=virtio tag%s %s/ -oversion=9p2000.L,posixacl,cache=loose\n' "$count" "$mountToFolderPath"
	
			count=$((count + 1))
		done <<-EOF
			${reproducible_mount}
		EOF
	
		cat <<-'EOF'
			exec busybox su \
				-p \
				-s /bin/sh \
				-c 'exec /su-command' \
				currentuser
		EOF
	} >"$initFilePath"
	
	chmod 0700 "$initFilePath"
}

depends find cpio gzip
reproducible_qemu_createInitialRamdiskCpioArchive()
{
	rm -rf "$reproducible_qemu_initialRamdiskCpioArchiveFilePath"
	
	cd "$reproducible_chrootFolderPath" 1>/dev/null 2>/dev/null
		# TODO: -R is not supported by busybox cpio.
		find . | cpio -o -H 'newc' -R 0:0 2>/dev/null | gzip -c >"$reproducible_qemu_initialRamdiskCpioArchiveFilePath"
	cd - 1>/dev/null 2>/dev/null
}

depends rm
reproducible_qemu_createEmptyDiskImage()
{
	rm -rf "$reproducible_qemu_disk0MountFolderPath"
	"$reproducible_qemu_compileForMacos_installPath"/bin/qemu-img create -f raw "$reproducible_qemu_disk0MountFolderPath" "$reproducible_qemu_disk0Size" 1>/dev/null 2>/dev/null
}

reproducible_qemu_execute()
{
	# Attempts to exit QEMU on Linux kernel panic; see second comment at https://unix.stackexchange.com/questions/443017/can-i-make-qemu-exit-with-failure-on-kernel-panic for a better option if the kernel supports pvpanic.
	set -- \
		-runas "$SUDO_UID":"$SUDO_GID" \
		-no-reboot \
		-nographic \
		-kernel "$reproducible_mirrorFolderPath"/vmlinuz \
		-drive index="$reproducible_qemu_disk0Index",media=disk,snapshot=off,format=raw,file="$reproducible_qemu_disk0FilePath" \
		-initrd "$reproducible_qemu_initialRamdiskCpioArchiveFilePath" \
		-append "root=/dev/$reproducible_qemu_disk0Name console=ttyS0 quiet kernel.panic=-1" \
			-m "$reproducible_qemu_memorySize" \
			-k en-us

	local mountFromFolderPath
	local mountToFolderPath
	local recursiveMount
	local count=0
	while IFS=':' read -r mountFromFolderPath mountToFolderPath recursiveMount
	do
		if [ -z "$mountFromFolderPath" ]; then
			continue
		fi
		
		set -- "$@" \
			-fsdev local,id="id${count}",path="$mountFromFolderPath",security_model=none \
			-device virtio-9p-pci,fsdev="id${count}",mount_tag="tag${count}"
		
		count=$((count +1 ))
	done <<-EOF
		${reproducible_mount}
	EOF
	
	exec "$reproducible_qemu_compileForMacos_installPath"/bin/qemu-system-x86_64 "$@"
}

reproducible_qemu_main()
{
	cd "$(_program_path_find)"/.. 1>/dev/null 2>/dev/null

	. "$(pwd)"/functions/reproducible.functions

	local environment_parseCommandLineArguments_message="${program_name}:  Enters an Alpine Linux QEMU virtual instance.

Usage: ${program_name} -h | --help
Usage: ${program_name} [-c|--configuration /path/to/configuration/folder] [-o|--output /path/to/output/folder [-m|--mount from1:to1:recursive1,from2:to2:recursive2]]

If the configuration folder path is not provided, it defaults to program_location/sample-configuration.

If the output folder path is not provided, it defaults to program_location/output. The output folder path is created as necessary.

The mount argument is a triplet of from folder path and to folder path and true/false for recursive mounting. It can be repeated.
from folder path and to folder path should not contain colons or new lines.
"
	local reproducible_mount=""
	_additionalArgumentsCallback()
	{
		case "$key" in
			-m|--mount)
				environment_parseCommandLineArguments_missingArgument "$@"
				reproducible_mount="${reproducible_mount}
${value}"
				_additionalArgumentsCallback_shiftUp=1
			;;

			--mount=*)
				value="${key##--mount=}"
				reproducible_mount="${reproducible_mount}
${value}"
			;;

			-m*)
				environment_parseCommandLineArguments_alreadyParsed $reproducible_configurationFolderPathParsed
				value="${key##-m}"
				reproducible_mount="${reproducible_mount}
${value}"
			;;

			*)
				environment_parseCommandLineArguments_errorHelp "Unexpected argument '$key'"
			;;
		esac
	}
	_positionalArgumentsCallback()
	{
		if [ $# -eq 0 ]; then
			environment_parseCommandLineArguments_errorHelp "At least one positional argument should be specified (an absolute path to a binary to run in the chroot)"
		fi
	}
	local reproducible_positionalArgumentsStartAt
	local reproducible_configurationFolderPath="$(pwd)"/sample-configuration
	local reproducible_outputFolderPath="$(pwd)"/output
	reproducible_parseCommandLineArguments _additionalArgumentsCallback _positionalArgumentsCallback "$@"
	
	reproducible_validateCommandLineArguments

	local reproducible_temporaryFolderPath
	local reproducible_versionFilePath
	local reproducible_packagesFilePath
	local reproducible_busyboxStaticBinariesFilePath
	local reproducible_mirrorFolderPath
	local reproducible_mirrorVersionFilePath
	local reproducible_indexFolderPath
	local reproducible_indexVersionFilePath
	local reproducible_packagesFolderPath
	local reproducible_packagesVersionFilePath
	local reproducible_extractedPackagesFolderPath
	local reproducible_extractedPackagesVersionFilePath
	local reproducible_extractedPackagesPackagesFilePath
	local reproducible_extractedPackagesBusyboxStaticBinariesFilePath
	local reproducible_extractedInitramfsFolderPath
	local reproducible_extractedInitramfsVersionFilePath
	local reproducible_majorVersion
	local reproducible_minorVersion
	local reproducible_revisionVersion
	local reproducible_apkToolsVersion
	local reproducible_versionMirror
	local reproducible_releasesMirror
	local reproducible_architecture
	local reproducible_chrootFolderPath
	reproducible_setEnvironmentVariables

	local reRunAsRoot=true
	if [ -n "${SUDO_UID+isset}" ]; then
		reRunAsRoot=false
	fi
	
	if [ "$(uname)" = 'Darwin' ]; then
		"$(pwd)"/reproducible-macports/repoducible-port-list
		export PATH="$(pwd)"/reproducible-macports.conf/bin:"$(pwd)"/reproducible-macports.conf/sbin:/usr/bin:/usr/sbin:/bin:/sbin
	fi

	local reproducible_qemu_memorySize='1G'
	
	local reproducible_qemu_disk0Uuid='d2c4a813-877e-44d1-8b3b-0b32139d7ee6'
	local reproducible_qemu_disk0Index='0'
	local reproducible_qemu_disk0Name='hda'
	local reproducible_qemu_disk0Size='1G'
	local reproducible_qemu_disk0MountFolderPath
	local reproducible_qemu_disk0FilePath
	local reproducible_qemu_initialRamdiskCpioArchiveFilePath="$reproducible_temporaryFolderPath"/initramfs.cpio.gz
	
	if $reRunAsRoot; then
		"$(pwd)"/support/alpine-linux-download --configuration "$reproducible_configurationFolderPath" --output "$reproducible_outputFolderPath"
		
		reproducible_createChroot
		reproducible_createSuCommandToRunAsCurrentUser "$@"
		reproducible_qemu_makeInitFile
		reproducible_qemu_createInitialRamdiskCpioArchive
		reproducible_qemu_createEmptyDiskImage
		environment_reRunAsRootIfRequired "$@"
	fi
	
	reproducible_qemu_execute
}

reproducible_qemu_main "$@"
